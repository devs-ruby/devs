module DEVS
  # The {Behavior} mixin provides models with several behavior methods
  # in line to the DEVS functions definition (δext, δint, δcon, λ and ta) and
  # the DEVS variables (σ, e, t).
  # The class must call {#initialize_behavior} during its initialization in
  # order to allocate instance variables.
  module Behavior
    extend ActiveSupport::Concern
    include AttrState

    included do
      attr_state :elapsed, default: 0.0
      attr_state :time, default: 0
      attr_state :sigma, default: INFINITY
    end

    attr_accessor :elapsed, :time, :sigma, :next_activation
    alias_method :next_activation, :sigma

    # @!attribute sigma
    #   Sigma is a convenient variable introduced to simplify modeling phase
    #   and represent the next activation time (see {#time_advance})
    #   @return [Numeric] Returns the sigma (σ) value

    # @!attribute elapsed
    #   This attribute is updated along simulation. It represents the elapsed
    #   time since the last transition.
    #   @return [Numeric] Returns the elapsed time since the last transition

    # @!attribute time
    #   This attribute is updated along with simulation clock and
    #   represent the last simulation time at which this model
    #   was activated. Its default assigned value is {INFINITY}.
    #   @return [Numeric] Returns the last activation time

    # @!group DEVS functions

    # The external transition function (δext)
    #
    # @abstract Override this method to implement the appropriate behavior of
    #   your model or define it with {self.external_transition}
    # @see self.external_transition
    # @param messages [Hash<Port,Object>] the messages generated by other
    #   {Model}s, indexed by input {Port}s.
    # @example
    #   def external_transition(messages)
    #     messages.each { |port, value|
    #       puts "#{port} => #{value}"
    #     }
    #
    #     self.sigma = 0
    #   end
    # @return [void]
    def external_transition(messages); end

    # Internal transition function (δint), called when the model should be
    # activated, e.g when {#elapsed} reaches {#time_advance}
    #
    # @abstract Override this method to implement the appropriate behavior of
    #   your model or define it with {self.internal_transition}
    # @see self.internal_transition
    # @example
    #   def internal_transition; self.sigma = DEVS::INFINITY; end
    # @return [void]
    def internal_transition; end

    # This is the default definition of the confluent transition. Here the
    # internal transition is allowed to occur and this is followed by the
    # effect of the external transition on the resulting state.
    #
    # Override this method to obtain a different behavior. For example, the
    # opposite order of effects (external transition before internal
    # transition). Of course you can override without reference to the other
    # transitions.
    #
    # @see AtomicModel.reverse_confluent_transition!
    # @todo see elapsed time reset
    def confluent_transition(messages)
      internal_transition
      external_transition(messages)
    end

    # Time advance function (ta), called after each transition to give a
    # chance to <tt>self</tt> to be active. By default returns {#sigma}
    #
    # @note Override this method to implement the appropriate behavior of
    #   your model or define it with {self.time_advance}
    # @see self.time_advance
    # @example
    #   def time_advance; self.sigma; end
    # @return [Numeric] the time to wait before the model will be activated
    def time_advance
      @sigma
    end

    # The output function (λ)
    #
    # @abstract Override this method to implement the appropriate behavior of
    #   your model or define it with {AtomicModel.output}
    # @see AtomicModel.output
    # @example
    #   def output
    #     post(@some_value, @output_ports[:output])
    #   end
    # @return [void]
    def output; end

    # @!endgroup

    module ClassMethods
      # @!group Class level DEVS functions

      # Defines the external transition function (δext) using the given block
      # as body.
      #
      # @see #external_transition
      # @example
      #   external_transition do |messages|
      #     messages.each { |msg| }
      #       puts "#{msg.port} => #{msg.payload}"
      #     end
      #
      #     self.sigma = 0
      #   end
      # @return [void]
      def external_transition(&block)
        define_method(:external_transition, &block) if block
      end

      # Defines the internal transition function (δint) using the given block
      # as body.
      #
      # @see #internal_transition
      # @example
      #   internal_transition { self.sigma = DEVS::INFINITY }
      # @return [void]
      def internal_transition(&block)
        define_method(:internal_transition, &block) if block
      end

      # Defines the confluent transition function (δcon) using the given block
      # as body.
      #
      # @see #confluent_transition
      # @example
      #   confluent_transition do |messages|
      #     internal_transition
      #     external_transition(messages)
      #   end
      # @return [void]
      def confluent_transition(&block)
        define_method(:confluent_transition, &block) if block
      end

      # Defines the opposite behavior of the default confluent transition
      # function (δcon).
      #
      # @see #confluent_transition
      # @example
      #   class MyModel < AtomicModel
      #     reverse_confluent_transition!
      #     # ...
      #   end
      def reverse_confluent_transition!
        define_method(:confluent_transition) do |messages|
          external_transition(messages)
          internal_transition
        end
      end

      # Defines the time advance function (ta) using the given block as body.
      #
      # @see #time_advance
      # @example
      #   time_advance { self.sigma }
      # @return [void]
      def time_advance(&block)
        define_method(:time_advance, &block) if block
      end

      # Defines the output function (λ) using the given block as body.
      #
      # @see #output
      # @example
      #   output do
      #     post(@some_value, output_ports.first)
      #   end
      # @return [void]
      def output(&block)
        define_method(:output, &block) if block
      end

      # @!endgroup
    end
  end
end
